# -*- coding: utf-8 -*-
"""
Created on Sun Jul 12 18:19:35 2020

@author: bradl
"""

import spacy
import random
import math
from spacy.matcher import Matcher
nlp = spacy.load('en_core_web_lg')
matcher = Matcher(nlp.vocab)

#Function that gets a count of a type of each part of speech
def pos_counts(document,pos_type):
    counter = 0
    for token in document:
        if token.pos_ == str(pos_type):
            counter += 1
        result = math.floor(counter/4)
    return result

#Function that gets a count of the ents in the doc
def ent_counts(document):
    counter = 0
    for ent in document.ents:
        counter += 1
    result = math.floor(counter/4)
    return result

#Gets a list of the POS for a given type in the doc
def pos_lister(document,pos_type):
    pos_type_list = []
    for token in document:
        if token.pos_ == str(pos_type) and token.lemma_ != '-PRON-':
            pos_type_list.append((token.text, token.pos_, spacy.explain(token.tag_)))
    return pos_type_list



#removes a random item from one of the pos lists
def my_pos_to_remove(pos_list,document,pos_counts):
    words_to_kill = []        
    if int(pos_counts) > 0:
        look_for = random.sample(pos_list,k=int(pos_counts))
        index = 0
        for item in look_for:
            #adds the random word to a pattern
            pattern1 = [{'LOWER': item[0].lower()}]
            #pattern1 = [{'LOWER':'dusty'}] #for testing only
            matcher.add('my_search',None,pattern1)
            found_match = matcher(document)
            #print(found_match[0][1:]) #for testing only
            for match_id, start, end in found_match:
                string_id = nlp.vocab.strings[match_id]  # get string representation
                span = document[start:end]                    # get the matched span
                #print(match_id, start, end, span.text) #for testing only
                #print(words_to_kill)
            if look_for[index][0] not in words_to_kill:
                words_to_kill.append((found_match[0][1:],item[2],look_for[index][0])) #look_for[index][0] for the word itself
            index += 1
            matcher.remove('my_search')
    return words_to_kill


def change_it(pos_to_replace_results):
    for item in pos_to_replace_results:
        place,pos,text = item
        replacement_input = input(f"Please enter a {pos}: ")
        new_text[int(place[0])] = replacement_input
    return new_text





#####GAME LOGIC#####

playing = True
while True:
    #Ask for text
    source_text = input(u"Paste in the text you would like to Madlib-ize: ")  #accept either typed string, text from clipboard, or txt file. can be later  
    
    doc = nlp(source_text)
    
    #this is to enable word replacement at an index position equivalent to the token span
    new_text = [token.text for token in doc]
    
    ###THIS GROUP COULD MAYBE BE MADE A CLASS??? THEN CREATE ONE FOR EACH TYPE OF THING?
    #run this group
    adj_list = pos_lister(doc,'ADJ')
    adj_counts = pos_counts(doc,'ADJ')
    adj_to_replace = my_pos_to_remove(adj_list,doc,adj_counts)
        
    ####END GROUP####
    
    change_it(adj_to_replace)
    
        
    print('\n') 
    print(' '.join(new_text))
    print('\n')    
    print('\n')
        
    new_game = input("Would you like to make another? Enter 'Yes' or 'No' ")
    if new_game[0].lower()=='y':
        playing=True
        continue
    else:
        print("Thanks for playing!")
        break
